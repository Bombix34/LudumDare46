using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace SplineMesh
{
    /// <summary>
    /// Example of component to show the deformation of the mesh on a changing
    /// interval and changing spline nodes.
    /// 
    /// In this example, as the MeshBender is working on spline space, it will update
    /// the mesh if one of the curve change. Each change make the MeshBender "dirty" and
    /// it will compute the mesh only once on it's next update call.
    /// 
    /// This component is only for demo purpose and is not intended to be used as-is.
    /// </summary>
    [RequireComponent(typeof(Spline))]
    public class DelayedSplineGenerator: MonoBehaviour
    {
        private GameObject generated;
        private Spline spline;
        private float rate = 0;
        private MeshBender meshBender;

        public Mesh mesh;
        public Material material;
        public Vector3 rotation;
        public Vector3 scale;

        public float startScale = 1;

        public float DurationInSecond;

        private float growAfterSize = 1f;
        public float growAfterSizeSpeed = 1f;

        private float delay = 0f;
        public float MaxDelay = 0f;

        public bool IsEndedGrowing { get; set; } = false;

        private void Start()
        {
            rate = 0;
            growAfterSize = 1f;
            delay = MaxDelay;
            IsEndedGrowing = false;
            Init();
        }


        bool isStarted = false;
        void Update()
        {
            if(delay>=0f)
            {
                delay -= Time.deltaTime;
                spline.nodes[0].Scale = Vector3.zero;
                return;
            }
            if (IsEndedGrowing)
            {
                return;
            }
            rate += Time.deltaTime / DurationInSecond;
            if (rate > 1)
            {
                if (growAfterSize < 8f)
                    growAfterSize += (Time.deltaTime * growAfterSizeSpeed);
                else
                    IsEndedGrowing = true;
            }
            Contort();
        }

        private void Contort()
        {
            float nodeDistance = 0;
            int i = 0;
            foreach (var n in spline.nodes)
            {
                Vector2 finalScale = spline.nodes[0].Scale;
                float nodeDistanceRate = nodeDistance / spline.Length;
                float nodeScale = startScale * (rate - (nodeDistanceRate));
                if (rate > 1)
                {
                    rate = 1;
                }
                n.Scale = new Vector2(nodeScale, nodeScale);
                if (i < spline.curves.Count)
                {
                    nodeDistance += spline.curves[i++].Length;
                }
            }

            if (generated != null)
            {
                meshBender.SetInterval(spline, 0, spline.Length * rate);
                meshBender.ComputeIfNeeded();
            }
        }


        private void Init()
        {
            string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject,
                typeof(MeshFilter),
                typeof(MeshRenderer),
                typeof(MeshBender));

            generated.GetComponent<MeshRenderer>().material = material;
            if (generated.GetComponent<DecrepitEffect>() == null)
            {
                generated.AddComponent<DecrepitEffect>();
            }
            meshBender = generated.GetComponent<MeshBender>();
            spline = GetComponent<Spline>();

            meshBender.Source = SourceMesh.Build(mesh)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            meshBender.Mode = MeshBender.FillingMode.StretchToInterval;
            meshBender.SetInterval(spline, 0, 0.01f);
        }
    }
}
